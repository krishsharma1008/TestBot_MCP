/**
 * Playwright Integration
 * Handles test generation and execution using Playwright
 */

const fs = require('fs');
const path = require('path');
const { spawn, execSync } = require('child_process');

class PlaywrightIntegration {
  constructor(config = {}) {
    this.config = {
      projectPath: config.projectPath || process.cwd(),
      baseURL: config.baseURL || 'http://localhost:8000',
      port: config.port || 8000,
      startCommand: config.startCommand,
      testType: config.testType || 'both',
      timeout: config.timeout || 300000, // 5 minutes
      ...config,
    };

    this.serverProcess = null;
  }

  /**
   * Generate tests from PRD or Jira stories
   */
  async generateTests({ prdFile, jiraStories, testType }) {
    const testsDir = path.join(this.config.projectPath, 'tests', 'generated');

    // Ensure tests directory exists
    if (!fs.existsSync(testsDir)) {
      fs.mkdirSync(testsDir, { recursive: true });
    }

    const generatedTests = [];

    // Generate from Jira stories
    if (jiraStories && jiraStories.length > 0) {
      for (const story of jiraStories) {
        const testCode = this.generateTestFromStory(story, testType);
        const filename = `${story.key.toLowerCase().replace(/-/g, '_')}.spec.js`;
        const filepath = path.join(testsDir, filename);

        fs.writeFileSync(filepath, testCode, 'utf-8');
        generatedTests.push(filepath);

        console.error(`[Playwright] Generated test: ${filename}`);
      }
    }

    // Generate from PRD file
    if (prdFile && fs.existsSync(prdFile)) {
      const prdContent = fs.readFileSync(prdFile, 'utf-8');
      const scenarios = this.parsePRDScenarios(prdContent);

      for (const scenario of scenarios) {
        const testCode = this.generateTestFromScenario(scenario, testType);
        const filename = `prd_${scenario.name.toLowerCase().replace(/\s+/g, '_')}.spec.js`;
        const filepath = path.join(testsDir, filename);

        fs.writeFileSync(filepath, testCode, 'utf-8');
        generatedTests.push(filepath);

        console.error(`[Playwright] Generated test from PRD: ${filename}`);
      }
    }

    return {
      generated: generatedTests.length,
      files: generatedTests,
    };
  }

  /**
   * Generate test code from a Jira story
   */
  generateTestFromStory(story, testType) {
    const sanitizedSummary = this.sanitizeString(story.summary);
    const acceptanceCriteria = story.acceptanceCriteria || [];

    let testCases = '';
    acceptanceCriteria.forEach((criterion, index) => {
      testCases += `
  test('${this.sanitizeString(criterion)}', async ({ page }) => {
    // Test for: ${criterion}
    await page.goto('/');
    
    // TODO: Implement test based on acceptance criteria
    // Criterion: ${criterion}
    
    // Placeholder assertion
    await expect(page).toHaveURL(/.*\\/$/);
  });
`;
    });

    // If no acceptance criteria, generate a basic test
    if (acceptanceCriteria.length === 0) {
      testCases = `
  test('should display successfully', async ({ page }) => {
    await page.goto('/');
    await expect(page).toHaveTitle(/.*/);
  });
`;
    }

    return `// @ts-check
const { test, expect } = require('@playwright/test');

/**
 * ${story.key}: ${sanitizedSummary}
 * Status: ${story.status}
 * Priority: ${story.priority}
 * Generated by Testbot MCP
 */

test.describe('${story.key}: ${sanitizedSummary}', () => {
${testCases}
});
`;
  }

  /**
   * Generate test code from a PRD scenario
   */
  generateTestFromScenario(scenario, testType) {
    const steps = scenario.steps || [];

    let testSteps = steps.map((step, index) => {
      return `    // Step ${index + 1}: ${step}
    // TODO: Implement this step`;
    }).join('\n\n');

    if (!testSteps) {
      testSteps = '    // TODO: Implement test steps';
    }

    return `// @ts-check
const { test, expect } = require('@playwright/test');

/**
 * PRD Scenario: ${scenario.name}
 * Description: ${scenario.description || 'No description'}
 * Generated by Testbot MCP
 */

test.describe('${this.sanitizeString(scenario.name)}', () => {
  test('${this.sanitizeString(scenario.name)}', async ({ page }) => {
    await page.goto('/');
    
${testSteps}
    
    // Placeholder assertion
    await expect(page).toHaveTitle(/.*/);
  });
});
`;
  }

  /**
   * Parse PRD content for test scenarios
   */
  parsePRDScenarios(prdContent) {
    const scenarios = [];
    const lines = prdContent.split('\n');

    let currentScenario = null;
    let inScenario = false;

    for (const line of lines) {
      const trimmedLine = line.trim();

      // Detect scenario headers
      if (trimmedLine.match(/^#+\s*(scenario|test|feature|user story)/i)) {
        if (currentScenario) {
          scenarios.push(currentScenario);
        }
        currentScenario = {
          name: trimmedLine.replace(/^#+\s*/, ''),
          description: '',
          steps: [],
        };
        inScenario = true;
      } else if (inScenario && currentScenario) {
        // Parse Given/When/Then steps
        const stepMatch = trimmedLine.match(/^[-*]\s*(Given|When|Then|And)\s+(.+)/i);
        if (stepMatch) {
          currentScenario.steps.push(`${stepMatch[1]} ${stepMatch[2]}`);
        } else if (trimmedLine && !trimmedLine.startsWith('#')) {
          currentScenario.description += trimmedLine + ' ';
        }
      }
    }

    if (currentScenario) {
      scenarios.push(currentScenario);
    }

    return scenarios;
  }

  /**
   * Run Playwright tests
   */
  async runTests() {
    const projectPath = this.config.projectPath;

    // Start server if needed
    if (this.config.startCommand) {
      await this.startServer();
    }

    try {
      // Run Playwright tests
      const result = await this.executePlaywright();
      return result;
    } finally {
      // Stop server if we started it
      if (this.serverProcess) {
        this.stopServer();
      }
    }
  }

  /**
   * Execute Playwright test command
   */
  async executePlaywright() {
    return new Promise((resolve, reject) => {
      const projectPath = this.config.projectPath;
      const testResultsPath = path.join(projectPath, 'test-results.json');

      // Check if Playwright is installed
      const playwrightPath = path.join(projectPath, 'node_modules', '@playwright', 'test');
      if (!fs.existsSync(playwrightPath)) {
        console.error('[Playwright] Installing Playwright...');
        try {
          execSync('npm install -D @playwright/test', { cwd: projectPath, stdio: 'pipe' });
        } catch (error) {
          console.error('[Playwright] Failed to install Playwright:', error.message);
        }
      }

      // Build command
      const args = ['playwright', 'test', '--reporter=json'];

      // Add config if exists
      const configPath = path.join(projectPath, 'playwright.config.js');
      if (fs.existsSync(configPath)) {
        args.push('--config', configPath);
      }

      console.error(`[Playwright] Running: npx ${args.join(' ')}`);

      const proc = spawn('npx', args, {
        cwd: projectPath,
        env: {
          ...process.env,
          BASE_URL: this.config.baseURL,
        },
        shell: true,
      });

      let stdout = '';
      let stderr = '';

      proc.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      proc.stderr.on('data', (data) => {
        stderr += data.toString();
        console.error(data.toString());
      });

      proc.on('close', (code) => {
        // Parse results from test-results.json if it exists
        const results = this.parseTestResults(testResultsPath, stdout);
        resolve(results);
      });

      proc.on('error', (error) => {
        reject(new Error(`Playwright execution failed: ${error.message}`));
      });

      // Timeout
      setTimeout(() => {
        proc.kill();
        reject(new Error('Playwright execution timeout'));
      }, this.config.timeout);
    });
  }

  /**
   * Parse test results from JSON
   */
  parseTestResults(testResultsPath, stdout) {
    let results = {
      total: 0,
      passed: 0,
      failed: 0,
      skipped: 0,
      duration: 0,
      tests: [],
      failures: [],
    };

    console.error('[Playwright] Parsing test results...');
    console.error(`[Playwright] Looking for results file at: ${testResultsPath}`);

    // Try to parse from JSON file
    if (fs.existsSync(testResultsPath)) {
      const fileStats = fs.statSync(testResultsPath);
      console.error(`[Playwright] Found test-results.json (${fileStats.size} bytes)`);
      
      try {
        const data = JSON.parse(fs.readFileSync(testResultsPath, 'utf-8'));
        results = this.extractResultsFromJson(data);
        console.error(`[Playwright] Parsed ${results.total} tests from test-results.json`);
        console.error(`[Playwright] Results: ${results.passed} passed, ${results.failed} failed, ${results.skipped} skipped`);
      } catch (error) {
        console.error('[Playwright] ERROR: Failed to parse test-results.json:', error.message);
        console.error('[Playwright] This usually means the JSON file is malformed or empty');
      }
    } else {
      console.error('[Playwright] WARNING: test-results.json NOT FOUND at expected location');
      console.error('[Playwright] This typically happens when:');
      console.error('[Playwright]   1. Playwright config has reporter: "json" instead of reporter: [[\'json\', { outputFile: \'test-results.json\' }]]');
      console.error('[Playwright]   2. Tests failed to run at all');
      console.error('[Playwright]   3. Tests output to a different location');
    }

    // Fallback: try to parse from stdout
    if (results.total === 0 && stdout) {
      console.error('[Playwright] Attempting to parse results from stdout...');
      try {
        const jsonData = JSON.parse(stdout);
        results = this.extractResultsFromJson(jsonData);
        console.error(`[Playwright] Parsed ${results.total} tests from stdout JSON`);
      } catch (error) {
        // Not valid JSON, extract from text output
        console.error('[Playwright] stdout is not JSON, extracting from text output...');
        const passedMatch = stdout.match(/(\d+)\s+passed/);
        const failedMatch = stdout.match(/(\d+)\s+failed/);
        const skippedMatch = stdout.match(/(\d+)\s+skipped/);

        results.passed = passedMatch ? parseInt(passedMatch[1], 10) : 0;
        results.failed = failedMatch ? parseInt(failedMatch[1], 10) : 0;
        results.skipped = skippedMatch ? parseInt(skippedMatch[1], 10) : 0;
        results.total = results.passed + results.failed + results.skipped;
        
        if (results.total > 0) {
          console.error(`[Playwright] Extracted from text: ${results.passed} passed, ${results.failed} failed, ${results.skipped} skipped`);
        } else {
          console.error('[Playwright] WARNING: Could not extract any test results from stdout');
        }
      }
    }

    // Final warning if no tests found
    if (results.total === 0) {
      console.error('[Playwright] ⚠️  CRITICAL: No test results found!');
      console.error('[Playwright] The dashboard report will show 0 tests.');
      console.error('[Playwright] To fix this, ensure your playwright.config.js has:');
      console.error('[Playwright]   reporter: [[\'json\', { outputFile: \'test-results.json\' }]]');
      console.error('[Playwright] Run: node scripts/debug-dashboard.js for detailed diagnostics');
    }

    return results;
  }

  /**
   * Extract results from Playwright JSON output
   */
  extractResultsFromJson(data) {
    const results = {
      total: 0,
      passed: 0,
      failed: 0,
      skipped: 0,
      duration: 0,
      tests: [],
      failures: [],
    };

    // Log structure info for debugging
    if (!data) {
      console.error('[Playwright] extractResultsFromJson: data is null/undefined');
      return results;
    }
    
    if (!data.suites) {
      console.error('[Playwright] extractResultsFromJson: No suites found in data');
      console.error('[Playwright] Data keys:', Object.keys(data));
      return results;
    }
    
    console.error(`[Playwright] extractResultsFromJson: Processing ${data.suites.length} top-level suites`);

    const processSpec = (spec, suiteName) => {
      if (spec.tests) {
        for (const test of spec.tests) {
          const lastResult = test.results?.[test.results.length - 1];
          const status = lastResult?.status || test.status;

          const testObj = {
            id: `${suiteName}-${spec.title}`.replace(/\s+/g, '-'),
            title: spec.title,
            suite: suiteName,
            file: spec.file,
            status,
            duration: lastResult?.duration || 0,
            error: lastResult?.error || null,
          };

          results.tests.push(testObj);
          results.total++;
          results.duration += testObj.duration;

          switch (status) {
            case 'passed':
            case 'expected':
              results.passed++;
              break;
            case 'failed':
            case 'unexpected':
            case 'timedOut':
              results.failed++;
              results.failures.push({
                testName: spec.title,
                file: spec.file,
                error: lastResult?.error || {},
                status,
                duration: testObj.duration,
                artifacts: this.extractArtifacts(lastResult?.attachments || []),
              });
              break;
            case 'skipped':
            case 'pending':
              results.skipped++;
              break;
          }
        }
      }
    };

    const processSuite = (suite, parentName = '') => {
      const suiteName = parentName ? `${parentName} > ${suite.title}` : suite.title;

      if (suite.specs) {
        for (const spec of suite.specs) {
          processSpec(spec, suiteName);
        }
      }

      if (suite.suites) {
        for (const childSuite of suite.suites) {
          processSuite(childSuite, suiteName);
        }
      }
    };

    if (data.suites) {
      for (const suite of data.suites) {
        processSuite(suite);
      }
    }

    // Log extraction summary
    console.error(`[Playwright] Extraction complete: ${results.total} tests found`);
    if (results.failures.length > 0) {
      console.error(`[Playwright] ${results.failures.length} test(s) have failures with artifacts`);
    }

    return results;
  }

  /**
   * Extract artifacts from test attachments
   */
  extractArtifacts(attachments) {
    const artifacts = {
      screenshots: [],
      videos: [],
      traces: [],
      errorContext: null,
    };

    for (const attachment of attachments) {
      if (attachment.contentType?.includes('image')) {
        artifacts.screenshots.push({
          name: attachment.name,
          path: attachment.path,
        });
      } else if (attachment.contentType?.includes('video')) {
        artifacts.videos.push({
          name: attachment.name,
          path: attachment.path,
        });
      } else if (attachment.name?.includes('trace')) {
        artifacts.traces.push({
          name: attachment.name,
          path: attachment.path,
        });
      }
    }

    return artifacts;
  }

  /**
   * Load test results from a file
   */
  async loadTestResults(testResultsPath) {
    if (!fs.existsSync(testResultsPath)) {
      throw new Error(`Test results not found: ${testResultsPath}`);
    }

    const data = JSON.parse(fs.readFileSync(testResultsPath, 'utf-8'));
    return this.extractResultsFromJson(data);
  }

  /**
   * Start the application server
   */
  async startServer() {
    if (!this.config.startCommand) return;

    return new Promise((resolve, reject) => {
      console.error(`[Playwright] Starting server: ${this.config.startCommand}`);

      const [cmd, ...args] = this.config.startCommand.split(' ');

      this.serverProcess = spawn(cmd, args, {
        cwd: this.config.projectPath,
        shell: true,
        detached: true,
      });

      this.serverProcess.stdout.on('data', (data) => {
        console.error(`[Server] ${data.toString()}`);
      });

      this.serverProcess.stderr.on('data', (data) => {
        console.error(`[Server] ${data.toString()}`);
      });

      // Wait for server to be ready
      const checkServer = async () => {
        const maxAttempts = 30;
        for (let i = 0; i < maxAttempts; i++) {
          try {
            const response = await fetch(this.config.baseURL);
            if (response.ok || response.status < 500) {
              console.error('[Playwright] Server is ready');
              resolve();
              return;
            }
          } catch (error) {
            // Server not ready yet
          }
          await new Promise((r) => setTimeout(r, 1000));
        }
        reject(new Error('Server failed to start within timeout'));
      };

      checkServer();
    });
  }

  /**
   * Stop the application server
   */
  stopServer() {
    if (this.serverProcess) {
      console.error('[Playwright] Stopping server');
      // Kill process group
      try {
        process.kill(-this.serverProcess.pid);
      } catch (error) {
        this.serverProcess.kill();
      }
      this.serverProcess = null;
    }
  }

  /**
   * Sanitize string for use in test names
   */
  sanitizeString(str) {
    if (!str) return '';
    return str
      .replace(/['"]/g, '')
      .replace(/[<>]/g, '')
      .replace(/\n/g, ' ')
      .trim()
      .substring(0, 100);
  }
}

module.exports = PlaywrightIntegration;

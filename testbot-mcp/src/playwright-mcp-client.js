/**
 * Playwright MCP Client
 * Handles communication with the official Playwright MCP server
 * and provides fallback test generation when MCP is unavailable
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

class PlaywrightMCPClient {
  constructor(config = {}) {
    this.config = {
      projectPath: config.projectPath || process.cwd(),
      baseURL: config.baseURL || 'http://localhost:3000',
      timeout: config.timeout || 60000,
      ...config,
    };
    
    this.mcpAvailable = false;
  }

  /**
   * Check if Playwright MCP is available
   */
  async checkMCPAvailability() {
    // For now, we'll use the fallback generator
    // In production, this would check if playwright-mcp server is running
    this.mcpAvailable = false;
    return this.mcpAvailable;
  }

  /**
   * Generate tests from codebase context
   * Uses AI agent's understanding of the codebase
   */
  async generateTests({ context, testType, projectPath, prdFile }) {
    const log = (msg) => console.error(`[PlaywrightMCP] ${msg}`);
    
    log('Generating tests from codebase context...');
    
    const testsDir = path.join(projectPath || this.config.projectPath, 'tests', 'generated');
    
    // Ensure directory exists
    if (!fs.existsSync(testsDir)) {
      fs.mkdirSync(testsDir, { recursive: true });
    }
    
    const generatedTests = [];
    
    // Generate frontend tests if context has pages
    if ((testType === 'frontend' || testType === 'both') && context?.pages) {
      log(`Generating frontend tests for ${context.pages.length} pages...`);
      for (const page of context.pages) {
        const test = this.generatePageTest(page, testsDir);
        if (test) {
          generatedTests.push(test);
          log(`Generated: ${test.filename}`);
        }
      }
    }
    
    // Generate backend tests if context has API endpoints
    if ((testType === 'backend' || testType === 'both') && context?.apiEndpoints) {
      log(`Generating API tests for ${context.apiEndpoints.length} endpoints...`);
      for (const endpoint of context.apiEndpoints) {
        const test = this.generateAPITest(endpoint, testsDir);
        if (test) {
          generatedTests.push(test);
          log(`Generated: ${test.filename}`);
        }
      }
    }
    
    // Generate workflow tests if context has workflows
    if (context?.workflows) {
      log(`Generating workflow tests for ${context.workflows.length} workflows...`);
      for (const workflow of context.workflows) {
        const test = this.generateWorkflowTest(workflow, testsDir);
        if (test) {
          generatedTests.push(test);
          log(`Generated: ${test.filename}`);
        }
      }
    }
    
    // If no context provided, generate basic smoke tests
    if (generatedTests.length === 0) {
      log('No context provided, generating basic smoke tests...');
      const basicTest = this.generateBasicSmokeTest(testsDir);
      generatedTests.push(basicTest);
    }
    
    // Create playwright.config.js if it doesn't exist
    await this.ensurePlaywrightConfig(projectPath || this.config.projectPath);
    
    log(`Generated ${generatedTests.length} test files`);
    
    return {
      generated: generatedTests.length,
      files: generatedTests.map(t => t.filePath),
      tests: generatedTests,
    };
  }

  /**
   * Generate test for a frontend page
   */
  generatePageTest(page, testsDir) {
    const pagePath = page.path || '/';
    const safeName = pagePath.replace(/\//g, '_').replace(/^_/, '') || 'home';
    const filename = `page_${safeName}.spec.js`;
    const filePath = path.join(testsDir, filename);
    
    const components = page.components || [];
    const interactions = page.interactions || [];
    const description = page.description || `${pagePath} page`;
    
    const code = `// @ts-check
const { test, expect } = require('@playwright/test');

/**
 * Tests for: ${description}
 * Path: ${pagePath}
 * Generated by Testbot MCP
 */

test.describe('${description}', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('${pagePath}');
  });

  test('should load page successfully', async ({ page }) => {
    // Verify page loads
    await expect(page).toHaveURL(new RegExp('${pagePath.replace(/\//g, '\\/')}'));
    
    // Wait for page to be ready
    await page.waitForLoadState('domcontentloaded');
  });

${components.map(comp => `  test('should display ${comp} component', async ({ page }) => {
    // Look for ${comp} by various selectors
    const element = page.locator(\`
      [data-testid="${comp.toLowerCase().replace(/\s+/g, '-')}"],
      [class*="${comp.toLowerCase()}"],
      text=${comp}
    \`.replace(/\\s+/g, '').split(',').join(', '));
    
    // At least one selector should match
    await expect(element.first()).toBeVisible({ timeout: 10000 }).catch(() => {
      // Fallback: check if any text contains the component name
      return expect(page.getByText(new RegExp('${comp}', 'i')).first()).toBeVisible();
    });
  });
`).join('\n')}

${interactions.map(interaction => {
  const interactionLower = interaction.toLowerCase();
  if (interactionLower.includes('input') || interactionLower.includes('field')) {
    return `  test('should have working ${interaction}', async ({ page }) => {
    const input = page.locator('input, textarea').filter({ hasText: /${interaction.split(' ')[0]}/i }).first();
    await input.waitFor({ timeout: 5000 }).catch(() => {});
    
    // If specific input not found, try any visible input
    const anyInput = page.locator('input:visible, textarea:visible').first();
    await expect(anyInput).toBeVisible();
  });
`;
  } else if (interactionLower.includes('button') || interactionLower.includes('submit')) {
    return `  test('should have working ${interaction}', async ({ page }) => {
    const button = page.locator('button, [type="submit"], [role="button"]').filter({ hasText: /${interaction.split(' ')[0]}/i }).first();
    await button.waitFor({ timeout: 5000 }).catch(() => {});
    
    // Verify button exists
    const anyButton = page.locator('button:visible, [type="submit"]:visible').first();
    await expect(anyButton).toBeVisible();
  });
`;
  } else if (interactionLower.includes('link')) {
    return `  test('should have working ${interaction}', async ({ page }) => {
    const link = page.locator('a').filter({ hasText: /${interaction.split(' ')[0]}/i }).first();
    await expect(link).toBeVisible({ timeout: 5000 }).catch(() => {
      // Fallback: any link should be visible
      return expect(page.locator('a:visible').first()).toBeVisible();
    });
  });
`;
  }
  return '';
}).filter(Boolean).join('\n')}
});
`;

    fs.writeFileSync(filePath, code, 'utf-8');
    
    return {
      filename,
      filePath,
      type: 'frontend',
      page: pagePath,
    };
  }

  /**
   * Generate test for an API endpoint
   */
  generateAPITest(endpoint, testsDir) {
    const method = endpoint.method || 'GET';
    const apiPath = endpoint.path || '/api/health';
    const safeName = apiPath.replace(/\//g, '_').replace(/^_/, '').replace(/:/g, '');
    const filename = `api_${method.toLowerCase()}_${safeName}.spec.js`;
    const filePath = path.join(testsDir, filename);
    
    const requiresAuth = endpoint.requiresAuth || endpoint.auth || false;
    const description = endpoint.description || `${method} ${apiPath}`;
    const requestBody = endpoint.requestBody || endpoint.expects || null;
    
    const code = `// @ts-check
const { test, expect } = require('@playwright/test');

/**
 * API Tests for: ${description}
 * Endpoint: ${method} ${apiPath}
 * Generated by Testbot MCP
 */

test.describe('API: ${method} ${apiPath}', () => {
  test('should respond with success status', async ({ request }) => {
    const response = await request.${method.toLowerCase()}('${apiPath}'${requestBody ? `, {
      data: ${JSON.stringify(requestBody, null, 6).replace(/\n/g, '\n      ')}
    }` : ''});
    
    // API should respond (2xx or expected error codes)
    expect([200, 201, 204, 400, 401, 403, 404]).toContain(response.status());
  });

  test('should return valid response format', async ({ request }) => {
    const response = await request.${method.toLowerCase()}('${apiPath}'${requestBody ? `, {
      data: ${JSON.stringify(requestBody, null, 6).replace(/\n/g, '\n      ')}
    }` : ''});
    
    if (response.ok()) {
      const contentType = response.headers()['content-type'] || '';
      
      // Most APIs return JSON
      if (contentType.includes('application/json')) {
        const data = await response.json();
        expect(data).toBeDefined();
      }
    }
  });

${requiresAuth ? `  test('should require authentication', async ({ request }) => {
    // Make request without auth headers
    const response = await request.${method.toLowerCase()}('${apiPath}'${requestBody ? `, {
      data: ${JSON.stringify(requestBody, null, 6).replace(/\n/g, '\n      ')}
    }` : ''});
    
    // Should return 401 or 403 if auth is required
    if (response.status() === 401 || response.status() === 403) {
      expect(true).toBeTruthy(); // Auth required as expected
    } else {
      // Auth might be optional or endpoint is public
      expect([200, 201, 204]).toContain(response.status());
    }
  });
` : ''}
});
`;

    fs.writeFileSync(filePath, code, 'utf-8');
    
    return {
      filename,
      filePath,
      type: 'backend',
      endpoint: `${method} ${apiPath}`,
    };
  }

  /**
   * Generate test for a user workflow
   */
  generateWorkflowTest(workflow, testsDir) {
    const workflowName = typeof workflow === 'string' ? workflow : workflow.name || 'User Workflow';
    const safeName = workflowName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
    const filename = `workflow_${safeName}.spec.js`;
    const filePath = path.join(testsDir, filename);
    
    const steps = workflow.steps || [];
    
    const code = `// @ts-check
const { test, expect } = require('@playwright/test');

/**
 * Workflow Test: ${workflowName}
 * Generated by Testbot MCP
 */

test.describe('Workflow: ${workflowName}', () => {
  test('should complete ${workflowName.toLowerCase()} successfully', async ({ page }) => {
    // Start at home page
    await page.goto('/');
    await page.waitForLoadState('domcontentloaded');
    
${steps.length > 0 ? steps.map((step, i) => `    // Step ${i + 1}: ${step}
    // TODO: Implement this step based on your app
    await page.waitForTimeout(100); // Placeholder
`).join('\n') : `    // Workflow steps to be implemented based on actual app behavior
    // The app should be navigable and responsive
    await expect(page.locator('body')).toBeVisible();
`}
    
    // Verify workflow completed
    // Add assertions based on expected end state
  });

  test('should handle errors gracefully', async ({ page }) => {
    await page.goto('/');
    
    // Test error handling
    // Add test cases for error scenarios
    await expect(page.locator('body')).toBeVisible();
  });
});
`;

    fs.writeFileSync(filePath, code, 'utf-8');
    
    return {
      filename,
      filePath,
      type: 'workflow',
      workflow: workflowName,
    };
  }

  /**
   * Generate basic smoke tests when no context is available
   */
  generateBasicSmokeTest(testsDir) {
    const filename = 'smoke_basic.spec.js';
    const filePath = path.join(testsDir, filename);
    
    const code = `// @ts-check
const { test, expect } = require('@playwright/test');

/**
 * Basic Smoke Tests
 * Generated by Testbot MCP
 * These tests verify basic app functionality
 */

test.describe('Basic Smoke Tests', () => {
  test('should load the application', async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('domcontentloaded');
    
    // Page should have a title
    const title = await page.title();
    expect(title).toBeTruthy();
    
    // Page should have visible content
    await expect(page.locator('body')).toBeVisible();
  });

  test('should have no console errors on load', async ({ page }) => {
    const errors = [];
    page.on('console', msg => {
      if (msg.type() === 'error') {
        errors.push(msg.text());
      }
    });
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    // Filter out known acceptable errors
    const criticalErrors = errors.filter(err => 
      !err.includes('favicon') && 
      !err.includes('404')
    );
    
    // No critical console errors
    expect(criticalErrors.length).toBeLessThanOrEqual(3);
  });

  test('should be responsive', async ({ page }) => {
    // Test desktop viewport
    await page.setViewportSize({ width: 1280, height: 720 });
    await page.goto('/');
    await expect(page.locator('body')).toBeVisible();
    
    // Test mobile viewport
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    await expect(page.locator('body')).toBeVisible();
  });

  test('should have working navigation', async ({ page }) => {
    await page.goto('/');
    
    // Find and test navigation links
    const navLinks = page.locator('nav a, header a, [role="navigation"] a');
    const linkCount = await navLinks.count();
    
    if (linkCount > 0) {
      // Test first navigation link
      const firstLink = navLinks.first();
      const href = await firstLink.getAttribute('href');
      
      if (href && !href.startsWith('http') && !href.startsWith('#')) {
        await firstLink.click();
        await page.waitForLoadState('domcontentloaded');
        // Should navigate without error
        await expect(page.locator('body')).toBeVisible();
      }
    }
  });
});
`;

    fs.writeFileSync(filePath, code, 'utf-8');
    
    return {
      filename,
      filePath,
      type: 'smoke',
    };
  }

  /**
   * Ensure playwright.config.js exists
   */
  async ensurePlaywrightConfig(projectPath) {
    const configPath = path.join(projectPath, 'playwright.config.js');
    
    if (fs.existsSync(configPath)) {
      return; // Config already exists
    }
    
    const config = `// @ts-check
const { defineConfig, devices } = require('@playwright/test');

/**
 * Playwright Configuration
 * Generated by Testbot MCP
 */
module.exports = defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [
    ['list'],
    ['json', { outputFile: 'test-results.json' }],
  ],
  
  use: {
    baseURL: process.env.BASE_URL || '${this.config.baseURL}',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],

  webServer: process.env.START_SERVER ? {
    command: process.env.START_COMMAND || 'npm start',
    url: process.env.BASE_URL || '${this.config.baseURL}',
    reuseExistingServer: !process.env.CI,
    timeout: 120000,
  } : undefined,
});
`;

    fs.writeFileSync(configPath, config, 'utf-8');
    console.error(`[PlaywrightMCP] Created playwright.config.js`);
  }
}

module.exports = PlaywrightMCPClient;

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class GitHubPRCreator {
  constructor(config = {}) {
    this.config = {
      githubToken: config.githubToken || process.env.GITHUB_TOKEN,
      repoOwner: config.repoOwner || this.extractRepoOwner(),
      repoName: config.repoName || this.extractRepoName(),
      baseBranch: config.baseBranch || 'main',
      branchPrefix: config.branchPrefix || 'ai-fix',
      autoMergeable: config.autoMergeable || false,
      ...config
    };
  }

  extractRepoOwner() {
    try {
      const remoteUrl = execSync('git config --get remote.origin.url', { encoding: 'utf-8' }).trim();
      console.log('DEBUG - Remote URL:', remoteUrl);
      
      // Handle SSH format: pers:ShreyesPD/ShipCruiseTour_POC.git
      if (remoteUrl.includes(':') && !remoteUrl.includes('://')) {
        const match = remoteUrl.match(/[:/]([^/]+)\/(.+?)(?:\.git)?$/);
        if (match) {
          console.log('DEBUG - Extracted owner (SSH):', match[1]);
          return match[1];
        }
      }
      
      // Handle HTTPS format
      const match = remoteUrl.match(/github\.com[:/]([^/]+)\//);
      const owner = match ? match[1] : null;
      console.log('DEBUG - Extracted owner (HTTPS):', owner);
      return owner;
    } catch (error) {
      console.error('Failed to extract repo owner:', error.message);
      return null;
    }
  }

  extractRepoName() {
    try {
      const remoteUrl = execSync('git config --get remote.origin.url', { encoding: 'utf-8' }).trim();
      
      // Handle SSH format: pers:ShreyesPD/ShipCruiseTour_POC.git
      if (remoteUrl.includes(':') && !remoteUrl.includes('://')) {
        const match = remoteUrl.match(/[:/]([^/]+)\/(.+?)(?:\.git)?$/);
        if (match) {
          console.log('DEBUG - Extracted repo (SSH):', match[2]);
          return match[2];
        }
      }
      
      // Handle HTTPS format
      const match = remoteUrl.match(/github\.com[:/][^/]+\/(.+?)(\.git)?$/);
      const repo = match ? match[1] : null;
      console.log('DEBUG - Extracted repo (HTTPS):', repo);
      return repo;
    } catch (error) {
      console.error('Failed to extract repo name:', error.message);
      return null;
    }
  }

  async createPR(analysisResults, fixResults) {
    console.log('\nüì§ Creating GitHub Pull Request...');

    const branchName = this.createBranch();
    const commitMessage = this.generateCommitMessage(analysisResults, fixResults);
    
    this.commitChanges(commitMessage);
    this.pushBranch(branchName);
    
    const prDetails = this.generatePRDetails(analysisResults, fixResults);
    const prUrl = await this.createGitHubPR(branchName, prDetails);
    
    console.log(`‚úÖ Pull Request created: ${prUrl}`);
    
    return {
      success: true,
      prUrl,
      branchName,
      commitMessage
    };
  }

  createBranch() {
    const timestamp = Date.now();
    const branchName = `${this.config.branchPrefix}-${timestamp}`;
    
    try {
      execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
      console.log(`‚úÖ Created branch: ${branchName}`);
      return branchName;
    } catch (error) {
      throw new Error(`Failed to create branch: ${error.message}`);
    }
  }

  commitChanges(message) {
    try {
      execSync('git add .', { stdio: 'inherit' });
      execSync(`git commit -m "${message}"`, { stdio: 'inherit' });
      console.log('‚úÖ Changes committed');
    } catch (error) {
      throw new Error(`Failed to commit changes: ${error.message}`);
    }
  }

  pushBranch(branchName) {
    try {
      execSync(`git push -u origin ${branchName}`, { stdio: 'inherit' });
      console.log(`‚úÖ Pushed branch: ${branchName}`);
    } catch (error) {
      throw new Error(`Failed to push branch: ${error.message}`);
    }
  }

  generateCommitMessage(analysisResults, fixResults) {
    const failureCount = analysisResults.failures?.length || 0;
    const fixCount = fixResults.successfulFixes || 0;
    
    return `ü§ñ AI-powered fix: Resolved ${fixCount}/${failureCount} test failures

- Automatically analyzed and fixed test failures
- Applied ${fixCount} successful fix(es)
- Generated by AI Agent on ${new Date().toISOString()}`;
  }

  generatePRDetails(analysisResults, fixResults) {
    const title = `ü§ñ AI Fix: Resolve ${fixResults.successfulFixes} test failure(s)`;
    
    let body = `## ü§ñ Automated Fix by AI Agent

This PR was automatically generated to fix test failures detected in the codebase.

### üìä Summary
- **Total Failures Detected:** ${analysisResults.failures?.length || 0}
- **Fixes Applied:** ${fixResults.successfulFixes}
- **Success Rate:** ${this.calculateSuccessRate(analysisResults, fixResults)}%
- **Timestamp:** ${new Date().toISOString()}

### üîç Failures Analyzed

`;

    if (analysisResults.analysisResults) {
      for (const result of analysisResults.analysisResults) {
        body += `#### ${result.failure.testName}
- **File:** \`${result.failure.file}\`
- **Error:** ${result.failure.error.message}
- **Analysis:** ${result.analysis}
- **Confidence:** ${(result.confidence * 100).toFixed(1)}%
- **Fix Applied:** ${result.suggestedFix ? '‚úÖ' : '‚ùå'}

`;
      }
    }

    body += `### üîß Changes Made

`;

    if (fixResults.appliedFixes) {
      for (const fix of fixResults.appliedFixes) {
        body += `- ${fix.success ? '‚úÖ' : '‚ùå'} ${fix.test} (${fix.file})
`;
      }
    }

    body += `
### üß™ Testing Recommendations

Please verify the following before merging:
1. Run the full test suite to ensure no regressions
2. Review the code changes for correctness
3. Test the affected functionality manually if needed

### üìù Additional Notes

This PR was generated automatically by the AI Agent system. The fixes were analyzed and applied based on test failure patterns and code context.

---
*Generated by AI Agent v1.0.0*
`;

    return { title, body };
  }

  calculateSuccessRate(analysisResults, fixResults) {
    const total = analysisResults.failures?.length || 0;
    const successful = fixResults.successfulFixes || 0;
    
    if (total === 0) return 0;
    return ((successful / total) * 100).toFixed(1);
  }

  async createGitHubPR(branchName, prDetails) {
    if (!this.config.githubToken) {
      console.log('\n‚ö†Ô∏è  GitHub token not found. Please create PR manually:');
      console.log(`   Branch: ${branchName}`);
      console.log(`   Title: ${prDetails.title}`);
      return `https://github.com/${this.config.repoOwner}/${this.config.repoName}/compare/${branchName}`;
    }

    try {
      const fetch = (await import('node-fetch')).default;
      
      const response = await fetch(
        `https://api.github.com/repos/${this.config.repoOwner}/${this.config.repoName}/pulls`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.config.githubToken}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28'
          },
          body: JSON.stringify({
            title: prDetails.title,
            body: prDetails.body,
            head: branchName,
            base: this.config.baseBranch,
            maintainer_can_modify: true
          })
        }
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(`GitHub API error: ${error.message}`);
      }

      const pr = await response.json();
      return pr.html_url;
    } catch (error) {
      console.error(`‚ùå Failed to create PR via API: ${error.message}`);
      return `https://github.com/${this.config.repoOwner}/${this.config.repoName}/compare/${branchName}`;
    }
  }

  async addLabels(prNumber, labels) {
    if (!this.config.githubToken) {
      return;
    }

    try {
      const fetch = (await import('node-fetch')).default;
      
      await fetch(
        `https://api.github.com/repos/${this.config.repoOwner}/${this.config.repoName}/issues/${prNumber}/labels`,
        {
          method: 'POST',
          headers: {
            'Authorization': `token ${this.config.githubToken}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github.v3+json'
          },
          body: JSON.stringify({ labels })
        }
      );
      
      console.log(`‚úÖ Added labels: ${labels.join(', ')}`);
    } catch (error) {
      console.error(`‚ö†Ô∏è  Failed to add labels: ${error.message}`);
    }
  }

  async addReviewers(prNumber, reviewers) {
    if (!this.config.githubToken) {
      return;
    }

    try {
      const fetch = (await import('node-fetch')).default;
      
      await fetch(
        `https://api.github.com/repos/${this.config.repoOwner}/${this.config.repoName}/pulls/${prNumber}/requested_reviewers`,
        {
          method: 'POST',
          headers: {
            'Authorization': `token ${this.config.githubToken}`,
            'Content-Type': 'application/json',
            'Accept': 'application/vnd.github.v3+json'
          },
          body: JSON.stringify({ reviewers })
        }
      );
      
      console.log(`‚úÖ Added reviewers: ${reviewers.join(', ')}`);
    } catch (error) {
      console.error(`‚ö†Ô∏è  Failed to add reviewers: ${error.message}`);
    }
  }
}

module.exports = GitHubPRCreator;
